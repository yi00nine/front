### 浏览器安全

#### xss 攻击及解决方法

跨站脚本攻击,通过注入恶意脚本,使用户在浏览器中执行该脚本，从而窃取用户信息、篡改网页内容或进行其他恶意行为。

1. **存储型 XSS（Stored XSS）：** 攻击者将恶意脚本存储在目标网站的数据库中，当用户浏览相关页面时，恶意脚本会被加载和执行。
2. **反射型 XSS（Reflected XSS）：** 攻击者将恶意脚本作为参数附加到目标网址中，当用户点击包含恶意脚本的链接时，网站会将恶意脚本反射给用户的浏览器执行。
3. **DOM 型 XSS（DOM-based XSS）：** 攻击者利用目标网站的客户端脚本，通过修改网页的 DOM 结构，从而触发执行恶意脚本

解决方式

1. **输入验证与过滤：** 对用户输入的数据进行验证和过滤，确保只接受预期的数据类型和格式。可以使用白名单机制，只允许特定的 HTML 标签、属性和特殊字符。
2. **HTTP-only 标记与安全的 Cookie：** 将敏感信息存储在 HTTP-only 标记的 Cookie 中，限制 JavaScript 的访问权限，这样可以防止 XSS 攻击获取敏感数据。

#### csrf(跨站请求伪造攻击) 及其解决方法

攻击者通过利用用户在已认证的网站上的身份，欺骗用户执行非预期的操作。攻击者构造一个请求，将其发送给目标网站，并利用用户的浏览器自动发送该请求，从而执行恶意操作。

- 进行同源检测 ，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤
- 对 Cookie 进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。

### 浏览器缓存

#### 浏览器缓存全过程

- 浏览器第一次加载服务器资源,服务器返回 200 状态码,并缓存资源文件和 response header
- 下一次请求资源的时候,会先去判断强制缓存,http1.1 通过 cache-control 判断,http1.0 通过 expires 来判断是否命中强制缓存,如果命中则直接从本地获取资源
- 如果资源已经过期,开始进行协商缓存,向服务器发送 if-none-match 和 if-modified-since 请求
- 服务器收到请求,优先按照 etag 的值来进行判断文件是否修改,etag 值一致的话命中协商缓存,服务器返回 304,如果不一致,则返回新的资源返回状态码 200
- 如果没有 etag,则对 if-modified-since 和 文件最后修改时间进行对比,一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200

#### 强制缓存和协商缓存的区别

- 强制缓存
  - expires(http1.0): 服务器在响应头添加 expires 属性,来指定过期时间
  - cache-control(http1.1): 通过 max-age 来设置缓存的最大时间
- 协商缓存

  - last-modified、if-modified-since:服务器在响应头添加 last-modified 字段来指出资源最后一次的修改时间,浏览器发起下一次请求的时候,会在请求头添加 if-modified-since 属性,该属性的值是上一次服务器返回的 last-modified.请求到达服务器会比较这两个值来判断是否命中协商缓存
  - etag、if-none-match(优先级高):服务器返回资源的时候,头信息添加了 etag 属性,etag 的值是资源的唯一标识符,下一次请求的时候请求头上添加 if-none-match 属性,值为 etag 返回.服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变.

  #### 刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别

  - 点击刷新按钮或者按 F5： 浏览器直接对本地的缓存文件过期，但是会带上 If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。
  - 用户按 Ctrl+F5（强制刷新）： 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。
  - 地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容

### 浏览器组成

#### 浏览器内核

- 渲染引擎: 即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式
- js 引擎: 解析和执行 javascript 来实现网页的动态效果

#### 常见浏览器内核

- Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink 内核；
- Safari 浏览器内核：Webkit 内核；
- Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；

#### 浏览器主要组成部分

- 用户界面: 用户界面是用户与浏览器进行交互的部分，包括地址栏、导航按钮、书签管理器等
- 渲染引擎:渲染引擎负责解析 HTML、CSS 和 JavaScript 等网页内容，并将其转换为可视化的页面
- 网络: 网络引擎处理浏览器与网络之间的通信。它负责发送 HTTP 请求到服务器并接收响应，以下载网页内容、图像、脚本和其他资源
- javascript 解释器: JavaScript 解释器负责解析和执行网页中的 JavaScript 代码
- 数据存储: 浏览器提供了多种数据存储机制，用于存储用户数据和网页内容。其中包括 Cookie、Local Storage、Session Storage 和 IndexedDB 等

### 浏览器渲染原理

#### 浏览器渲染过程

- 解析收到的文档,根据文档定义构建 dom 树,dom 树由 dom 元素以及属性节点组成
- 解析 css,生成 cssom 规则树
- 根据 dom 树和 cssom 树构建渲染树,渲染树的节点被称为渲染对象,渲染对象和 dom 元素相对应
- 根据渲染树进行布局和绘制，最终呈现在屏幕上

#### 浏览器渲染优化

- 减少回流和重绘的次数：避免频繁修改布局和样式属性，可以通过合并多个 DOM 操作、使用 CSS3 动画代替 JavaScript 动画等方式。
- 延迟加载和懒加载：只加载当前可视区域内的内容，减少不必要的资源请求和渲染。
- 压缩和合并 CSS 和 JavaScript 文件：减少文件大小，加快下载和解析速度
- 使用图片压缩和合适的格式：选择适当的图像格式、压缩图片以减少加载时间
- 使用缓存：合理设置缓存策略，减少重复请求

#### 渲染过程遇到 js 文件

在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档,想要首屏加载的速度变快,需要将 js 文件放在 body 的底部或者添加 defer 标签

### 浏览器本地存储

- cookie
  - 特性:
    - 无法跨域名
    - 每个域名下的 cookie 数量不能大于 20 大小不能大于 4kb
    - cookie 会添加在每一个请求上
  - 使用场景
    - 将 sessionId 存储到 Cookie 中，每次发请求都会携带这个 sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息
- localstorage
  - 特性:
    - LocalStorage 的大小一般为 5MB，可以储存更多的信息
    - 并不会随着页面的关闭而消失，除非主动清理
    - 受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问
- sessionstorage
  - 特性
    - 也有同源策略的限制，但是 SessionStorage 有一条更加严格的限制，SessionStorage 只有在同一浏览器的同一窗口下才能够共享；
    - 关闭窗口或标签页之后将会删除这些数据

### 同源策略

#### 同源策略的定义

同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。

#### 如何解决跨域

- cors : CORS 是一种基于 HTTP 头部的机制，允许服务器声明哪些来源（域、协议或端口）是被允许访问资源的。在服务端设置合适的响应头，如 Access-Control-Allow-Origin、Access-Control-Allow-Methods 等，来控制跨域访问的权限。
- 代理服务器: 在自己的服务器上创建一个代理服务器，将浏览器请求转发给目标服务器，并将目标服务器的响应返回给浏览器。这样，浏览器与代理服务器的请求是同源的，解决了跨域问题( 开发的时候配置 proxy 就是这个原理)

### 浏览器的事件机制

#### 阻止事件冒泡

- 普通浏览器使用：event.stopPropagation()
- IE 浏览器使用：event.cancelBubble = true;

#### 事件委托

- 事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）
- 事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托

#### 宏任务微任务

- 微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver
- 宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等

#### 对事件轮询的理解

- 执行同步任务：首先，浏览器会执行当前处于主线程的同步任务，直到所有同步任务执行完毕。

- 执行微任务：在同步任务执行完毕后，浏览器会检查是否存在微任务（Promise、MutationObserver 等），并按照先进先出的顺序依次执行微任务队列中的任务，直到微任务队列为空。

- 更新渲染：如果有需要更新渲染的操作（如修改 DOM、样式等），浏览器会执行这些操作，然后将结果渲染到屏幕上。

- 执行宏任务：在微任务执行完毕后，浏览器会检查是否存在宏任务（setTimeout、setInterval 等），并按照优先级依次执行一个宏任务队列中的任务，直到宏任务队列为空。

#### node 中的事件轮询和浏览器中的有什么不同

node.js 的运行机制

- V8 引擎解析 JavaScript 脚本。
- 解析后的代码，调用 Node API。
- libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。
- V8 引擎再将结果返回给用户。

libuv 中的六个阶段

- 定时器（Timer）阶段： 执行到期的定时器回调函数。
- I/O 阶段： 执行准备好的异步 I/O 操作的回调函数。
- 闲置（Idle）阶段： 执行一些额外的、系统级的操作。
- 轮询（Poll）阶段： 等待新的事件，并执行相应的回调函数。如果没有事件到达，则会等待或进入休眠状态。
- 检查（Check）阶段： 执行 setImmediate() 设定的回调函数。
- 关闭（Close）阶段： 执行一些准备关闭的回调函数，如关闭的文件描述符或服务器。

### 浏览器的垃圾回收

#### 垃圾回收机制

采用了分代式垃圾回收机制,V8 将内存分为新生代和老生代

- 新生代:在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了

  - 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中
  - To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中

- 老生代:老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法
  - 某个空间占用超过一定限制的时候会启动标记清除发
  - 清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存

#### 什么操作造成内存泄露

- 不合理的使用闭包，从而导致某些变量一直被留在内存当中
- 没有删除的设置了 setInterval 定时器
- 全局变量
