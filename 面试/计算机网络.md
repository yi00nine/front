### 1. http1.0 http1.1 http2.0 之间的区别

- http1.0:浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接
- http1.1:
  - 默认支持长连接（Connection: keep-alive），即在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟
  - 增加更多的请求头和响应头来完善的功能: If-Match, If-None-Match 等缓存头来控制缓存策略等
  - 添加了其他的请求方法：put、delete、options.
- http2.0(性能提升):
  - 多路复用:在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”
  - 采用二进制格式传输数据
  - 服务器推送

### 2. https 如何保证安全

`HTTPS`是建立在 `SSL`之上，其安全性由 `SSL`来保证

`SSL `的实现这些功能主要依赖于四种手段：

- 对称加密：对称加密指的是加密和解密使用的秘钥都是同一个，是对称的
- 非对称加密：公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密
- 摘要算法：可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”
- 数字签名：身份验证
- ca 验证:

  - 服务器的运营人员向数字证书认证机构提出公开密钥的申请
  - 数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名
  - 服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信
  - 接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，则证明
  - 认证服务器的公开密钥的是真实有效的数字证书认证机构
  - 服务器的公开密钥是值得信赖的

### 3. tcp 为什么要三次握手四次挥手

建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包来确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态
- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1 作为 ACK 的值，此时服务器处于 SYN_RCVD 的状态
- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的 ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接

终止一个连接，需要经过四次挥手

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态

### 4. tcp 和 udp 的区别以及使用场景

udp:用户数据包协议

- UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务
- 传输途中出现丢包，UDP 也不负责重发
- 当包的到达顺序出现乱序时，UDP 没有纠正的功能。
- 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为

tcp:传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送

- TCP 充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。
- 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。
- 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）

区别

- TCP 是面向连接的协议，建立连接 3 次握手、断开连接四次挥手，UDP 是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取

- TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方

- TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个 TCP 报文段传输后，在目的站重新装配。UDP 协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用

- TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信

### 5. 地址栏输入 url,后面发生什么

- URL 解析
- DNS 查询
- TCP 连接
- HTTP 请求
- 响应请求
- 页面渲染

### 6. http 常见的请求及其作用

- GET：用于请求获取指定资源的表示形式。GET 请求是幂等的，即多次重复的 GET 请求应该返回相同的结果，并且不应该对服务器产生任何副作用。通常用于获取数据。
- POST：用于向服务器提交数据，请求服务器接受并处理请求中包含的实体数据。POST 请求不是幂等的，每次发送 POST 请求，服务器可能会对资源进行修改、创建新资源、或执行其他操作。
- PUT：用于向服务器上传新的实体数据，或者替换指定资源的表示形式。PUT 请求的语义是完全替换目标资源或创建新资源，如果目标资源已经存在，则进行替换操作
- DELETE：用于请求服务器删除指定资源。DELETE 请求用于删除服务器上的资源，删除成功后，服务器应该返回 200 OK 或 204 No Content 状态码。
- OPTIONS：用于请求获取目标资源所支持的通信选项。OPTIONS 请求常用于跨域请求时的预检请求，用于确定服务器是否支持某种请求方法或特定的请求头

### 7. http 常见的状态及其使用场景

状态码第一位数字决定了不同的响应状态，有如下：

- 1xx:代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束

  - 100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应
  - 101：服务器根据客户端的请求切换协议，主要用于 websocket 或 http2 升级

- 2xx:代表请求已成功被服务器接收、理解、并接受

  - 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
  - 201:请求成功并且服务器创建了新的资源
  - 204:服务器成功处理请求，但没有返回任何内容
  - 206:服务器成功处理了部分请求

- 3xx 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向表示重定向

  - 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
  - 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
  - 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

- 4xx:代表了客户端看起来可能发生了错误，妨碍了服务器的处理
  - 400（错误请求）： 服务器不理解请求的语法
  - 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
  - 403（禁止）： 服务器拒绝请求
  - 404（未找到）： 服务器找不到请求的网页
  - 405（方法禁用）： 禁用请求中指定的方法
- 5xx:表示服务器错误
  - 500（服务器内部错误）：服务器遇到错误，无法完成请求
  - 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
  - 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
  - 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
  - 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
  - 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本

### 8. dns 协议以及 dns 完整的查询过程

域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器

域名缓存:

- 浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
- 操作系统缓存：操作系统的缓存其实是用户自己配置的 hosts 文件

解析域名的过程如下：

首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表

若没有命中，则继续搜索操作系统的 DNS 缓存

若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果

若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询

首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来

操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起

至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起

### 9. 如何理解 osi 七层模型

OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架

- 物理层:确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）该层主要是和硬件有关，与软件关系不大
- 数据链路层:在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧,主要协议 以太网
- 网络层:在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层
- 传输层:传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题,主要的传输层协议是 TCP 和 UDP
- 应用层:该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等

### 10. 如何理解 cdn,原理

CDN (全称 Content Delivery Network)，即内容分发网络
构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术

原理:
应用 CDN 后，DNS 返回的不再是 IP 地址，而是一个 CNAME(Canonical Name ) 别名记录，指向 CDN 的全局负载均衡

- 由于没有返回 IP 地址，于是本地 DNS 会向负载均衡系统再发送请求 ，则进入到 CDN 的全局负载均衡系统进行智能调度：

- 看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点

- 看用户所在的运营商网络，找相同网络的边缘节点

- 检查边缘节点的负载情况，找负载较轻的节点

- 其他，比如节点的“健康状况”、服务能力、带宽、响应时间等

### 11. 对 websocket 的理解以及使用场景

WebSocket，是一种网络传输协议，位于 OSI 模型的应用层。可在单个 TCP 连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅

- 较少的控制开销：数据包头部协议较小，不同于 http 每次请求需要携带完整的头部
- 更强的实时性：相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少
- 保持创连接状态：创建通信后，可省略状态信息，不同于 HTTP 每次请求需要携带身份验证
- 更好的二进制支持：定义了二进制帧，更好处理二进制内容
- 支持扩展：用户可以扩展 websocket 协议、实现部分自定义的子协议
- 更好的压缩效果：Websocket 在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率

基于 websocket 的事实通信的特点，其存在的应用场景大概有：

- 弹幕
- 媒体聊天
- 协同编辑
- 基于位置的应用
- 体育实况更新
- 股票基金报价实时更新
